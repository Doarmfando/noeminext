-- =====================================================
-- MIGRACIÓN: Renombrar campo empaquetado
-- FECHA: 2025-10-16
-- NIVEL DE RIESGO: MEDIO (requiere actualizar código)
-- REVERSIBLE: Sí (pero requiere revertir cambios de código)
-- =====================================================

-- ⚠️ ADVERTENCIA IMPORTANTE:
-- Esta migración renombra el campo "empaquetado" a "cantidad_por_empaquetado"
-- y cambia su tipo de string a numeric.
--
-- ANTES de aplicar esta migración, debes:
-- 1. Actualizar el código TypeScript para usar el nuevo nombre
-- 2. Probar que el código compila sin errores
-- 3. Luego aplicar esta migración
--
-- Si aplicas la migración SIN actualizar el código primero,
-- tu aplicación dejará de funcionar hasta que actualices el código.

-- =====================================================
-- PARTE 1: VERIFICAR DATOS ACTUALES
-- =====================================================

-- Verificar que todos los valores de empaquetado son numéricos válidos
DO $$
DECLARE
  invalid_count INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO invalid_count
  FROM detalle_contenedor
  WHERE empaquetado IS NOT NULL
    AND empaquetado !~ '^[0-9]+\.?[0-9]*$';

  IF invalid_count > 0 THEN
    RAISE EXCEPTION 'ERROR: Hay % registros con valores no numéricos en empaquetado. Debes limpiarlos primero.', invalid_count;
  END IF;

  RAISE NOTICE 'Verificación exitosa: Todos los valores de empaquetado son numéricos válidos';
END $$;

-- =====================================================
-- PARTE 2: RENOMBRAR Y CAMBIAR TIPO
-- =====================================================

-- Paso 1: Renombrar el campo
ALTER TABLE detalle_contenedor
RENAME COLUMN empaquetado TO cantidad_por_empaquetado;

-- Paso 2: Cambiar tipo de string a numeric
-- USING convierte los valores existentes de string a numeric
ALTER TABLE detalle_contenedor
ALTER COLUMN cantidad_por_empaquetado TYPE numeric
USING CASE
  WHEN cantidad_por_empaquetado IS NULL OR cantidad_por_empaquetado = '' THEN 0
  ELSE cantidad_por_empaquetado::numeric
END;

-- Paso 3: Establecer valor por defecto
ALTER TABLE detalle_contenedor
ALTER COLUMN cantidad_por_empaquetado SET DEFAULT 0;

-- Paso 4: Agregar constraint para que no sea negativo
ALTER TABLE detalle_contenedor
ADD CONSTRAINT chk_cantidad_por_empaquetado_positiva
CHECK (cantidad_por_empaquetado >= 0);

-- Paso 5: Eliminar el constraint anterior (si existe)
ALTER TABLE detalle_contenedor
DROP CONSTRAINT IF EXISTS chk_detalle_empaquetado_valido;

-- =====================================================
-- PARTE 3: ACTUALIZAR VISTA (si existe)
-- =====================================================

-- Si creaste la vista en la migración anterior, actualizarla
DROP VIEW IF EXISTS v_inventario_resumen CASCADE;

CREATE OR REPLACE VIEW v_inventario_resumen AS
SELECT
  -- Información del producto
  p.id as producto_id,
  p.nombre as producto_nombre,
  p.codigo as producto_codigo,
  p.descripcion as producto_descripcion,
  p.categoria_id,
  cat.nombre as categoria_nombre,
  p.unidad_medida_id,
  um.nombre as unidad_nombre,
  um.abreviatura as unidad_abrev,
  p.stock_min,
  p.precio_estimado,
  p.es_perecedero,

  -- Información del contenedor
  c.id as contenedor_id,
  c.nombre as contenedor_nombre,
  c.codigo as contenedor_codigo,
  tc.nombre as tipo_contenedor_nombre,

  -- Agregaciones de lotes (usando el nuevo nombre de campo)
  COUNT(dc.id) FILTER (WHERE dc.visible = true) as num_lotes,
  SUM(dc.cantidad) FILTER (WHERE dc.visible = true) as stock_total,

  -- Total de empaquetados (ahora usando cantidad_por_empaquetado)
  SUM(
    CASE
      WHEN dc.cantidad_por_empaquetado > 0 THEN
        (dc.cantidad / dc.cantidad_por_empaquetado)
      ELSE 0
    END
  ) FILTER (WHERE dc.visible = true) as total_empaquetados,

  -- Precio promedio ponderado
  CASE
    WHEN SUM(dc.cantidad) FILTER (WHERE dc.visible = true) > 0 THEN
      SUM(dc.cantidad * COALESCE(dc.precio_real_unidad, p.precio_estimado, 0))
        FILTER (WHERE dc.visible = true) /
      SUM(dc.cantidad) FILTER (WHERE dc.visible = true)
    ELSE COALESCE(p.precio_estimado, 0)
  END as precio_promedio,

  -- Valor total en inventario
  SUM(dc.cantidad * COALESCE(dc.precio_real_unidad, p.precio_estimado, 0))
    FILTER (WHERE dc.visible = true) as valor_total,

  -- Información de vencimientos
  MIN(dc.fecha_vencimiento) FILTER (WHERE dc.visible = true AND dc.fecha_vencimiento IS NOT NULL)
    as proxima_fecha_venc,

  COUNT(dc.id) FILTER (
    WHERE dc.visible = true
    AND dc.fecha_vencimiento IS NOT NULL
    AND dc.fecha_vencimiento <= CURRENT_DATE + INTERVAL '7 days'
    AND dc.fecha_vencimiento >= CURRENT_DATE
  ) as lotes_por_vencer,

  -- Flags útiles
  CASE
    WHEN SUM(dc.cantidad) FILTER (WHERE dc.visible = true) IS NULL THEN true
    WHEN SUM(dc.cantidad) FILTER (WHERE dc.visible = true) = 0 THEN true
    ELSE false
  END as sin_stock,

  CASE
    WHEN p.stock_min IS NOT NULL AND
         COALESCE(SUM(dc.cantidad) FILTER (WHERE dc.visible = true), 0) < p.stock_min
    THEN true
    ELSE false
  END as stock_bajo,

  -- Timestamps
  p.created_at as producto_created_at,
  p.updated_at as producto_updated_at

FROM productos p
LEFT JOIN categorias cat ON p.categoria_id = cat.id AND cat.visible = true
LEFT JOIN unidades_medida um ON p.unidad_medida_id = um.id AND um.visible = true
LEFT JOIN detalle_contenedor dc ON p.id = dc.producto_id
LEFT JOIN contenedores c ON dc.contenedor_id = c.id AND c.visible = true
LEFT JOIN tipos_contenedor tc ON c.tipo_contenedor_id = tc.id AND tc.visible = true

WHERE p.visible = true

GROUP BY
  p.id, p.nombre, p.codigo, p.descripcion, p.categoria_id, cat.nombre,
  p.unidad_medida_id, um.nombre, um.abreviatura,
  p.stock_min, p.precio_estimado, p.es_perecedero,
  c.id, c.nombre, c.codigo, tc.nombre,
  p.created_at, p.updated_at;

-- =====================================================
-- VERIFICACIÓN
-- =====================================================

-- Verificar que el campo fue renombrado correctamente
DO $$
BEGIN
  -- Verificar que el nuevo campo existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'detalle_contenedor'
    AND column_name = 'cantidad_por_empaquetado'
  ) THEN
    RAISE EXCEPTION 'ERROR: El campo cantidad_por_empaquetado no existe';
  END IF;

  -- Verificar que el viejo campo NO existe
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'detalle_contenedor'
    AND column_name = 'empaquetado'
  ) THEN
    RAISE EXCEPTION 'ERROR: El campo empaquetado todavía existe';
  END IF;

  -- Verificar que el tipo es numeric
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'detalle_contenedor'
    AND column_name = 'cantidad_por_empaquetado'
    AND data_type = 'numeric'
  ) THEN
    RAISE EXCEPTION 'ERROR: El campo cantidad_por_empaquetado no es tipo numeric';
  END IF;

  RAISE NOTICE 'Verificación exitosa:';
  RAISE NOTICE '- Campo renombrado: empaquetado → cantidad_por_empaquetado';
  RAISE NOTICE '- Tipo cambiado: string → numeric';
  RAISE NOTICE '- Constraint agregado: cantidad_por_empaquetado >= 0';
  RAISE NOTICE '- Vista actualizada';
  RAISE NOTICE '';
  RAISE NOTICE '⚠️  IMPORTANTE: Ahora debes actualizar tu código TypeScript';
  RAISE NOTICE '   para usar "cantidad_por_empaquetado" en lugar de "empaquetado"';
END $$;
